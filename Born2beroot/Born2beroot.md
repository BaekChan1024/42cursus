# Born2beroot

## 가상 머신이란?

- Virtual machine => 컴퓨터 환경을 소프트웨어로 구현한 것
  - 컴퓨터를 **에뮬레이션**하는 소프트웨어

>  추상적 개념 : 컴퓨터 안에 또 다른 컴퓨터를 동작 시킨다.

> 추상적 개념 : 컴퓨터의 주된 부품들의 기능을 소프트웨어적으로 구현해 가상으로 만들어서 구현

- 가상 머신의 구분

	* **시스템 가상 머신** : 실제 기계를 대체해서 제공하며, 전체 운영체제를 실행하기 위한 기능들을 제공 (과제에서 쓰는 것)
	* **프로세스 가상 머신** : 플랫폼에 독립적인 환경에서 컴퓨터 프로그램을 실행하기 위해 고안, 프로그래밍 언어의 하드웨어 추상화를 위해 사용

- 가상 머신 용어
  - **에뮬레이션(Emulation)** : 모든 부품의 모든 기능을 소프트웨어적으로 구현하는 방식, 속도는 느리나 범용성은 가장 뛰어남
  - **가상화(Virtualization)** : CPU 등 주요 부품의 기능에서 하드웨어의 기능을 지원 받음, 속도는 빠르나 해당 하드웨어에 종속되므로 범용성이 떨어짐
  
- 사용 목적
  - 하나의 컴퓨터로 서로다른 두개 이상의 운영체제를 실행하고자 할 때
  - 하나의 컴퓨터 자원을 여러 사용자에세 나누어 주는 상황에서 상호 간섭을 없애고 싶을로 때 
  - 컴퓨터의 다른 부분에 영향을 주지 않는 독립 환경을 만들고 싶을 때

- 사용 용도
  - 앱을 빌드하고 클라우드에 배포
  
  - 베타 릴리스를 비롯한 새로운 OS(운영 체제)를 테스트
  - 새로운 환경을 실행하여 개발자가 개발-테스트 시나리오를 더 쉽고 빠르게 실행
  - 기존 OS를 백업
  - 이전 OS를 설치하여 바이러스에 감염된 데이터에 액세스하거나 이전 애플리케이션을 실행
  - 원래 의도하지 않은 운영 체제에서 소프트웨어나 앱을 실행
## Debian 

- 장점
  - 기능의 다양성
  - 쉬운 유지보수
    - deb란 패키지로 묶어서 관리하고 있음 (이 방식의 장점은 deb 파일 안에 의존성 관련 정보를 저장하고 있어 필요한 외부 프로그램이나 라이브러리를 쉽게 알 수 있고, 패키지 관리 도구와 연계하여 패키지에서 필요로 하는 의존 패키지를 자동으로 데비안에서 운영하는 외부 저장소에서 가져와 설치할 수 있기 때문에 다른 배포판에 비해 관리가 편하다는 점)
  
    - 패키지 설치 및 업그레이드의 단순함 (패키지 매니저 apt를 이용하면 소프트웨어의 설치나 업데이트에서 다른 패키지와의 의존성 확인, 보안 관련 업데이트 등을 자동으로 설정 및 설치)

## CentOS
- 레드햇 계열 RHEL(레드햇 엔터프라이즈 리눅스)를 제대로 반영하고자 만들어진 배포판
  
- 기본적으로 포함되는 소프트웨어와 업데이트되는 소프트웨어를 아울러 이진 파일에 대해 상위판과 100%에 최대한 가까운 호환성을 유지하는 것이 원칙
- 장점
  - 리눅스 서버 시장의 1인자 RHEL를 무료로 사용 가능
- 단점
  - RHEL과 달리 사후 지원이 없음 (기업이 아닌 커뮤니티 차원)
  - 한국어 지원이 상당히 미비 (초보자들에게 진입 장벽이 높다)

## SELinux

- Secutity-Enhaced Linux

- 미국 국방부 스타일의 강제 접근 제어 (MAC)를 포함한 접근 제어 보안 정책을 지원하는 매커니즘을 제공하는 리눅스 커널 보안 모듈

- 다양한 리눅스 배포판에 추가할 수 있는 커널 수정 및 사용자 공간 도구들의 모임

- 레드햇 계열(RHEL, Fedora, CentOS)

- MAC 적용 (전통적인 Linux는 DAC)

- 시스템 전체에 보안 설정

<br>

## AppArmor

- Application Armor

- 시스템 관리자가 프로그램 프로필 별로 프로그램의 역량을 제한할 수 있게 해주는 리눅스 커널 보안 모듈

- SUSE 계열 (SUSE Linux), 데비안 계열 (Debian, Ubuntu)

- MAC 적용 (전통적인 Linux는 DAC)

- 개별 응용 프로그램을 보호하는 일에 집중

- 응용 프로그램 단위의 보안 모델 구현

- AppArmor는 SELinux를 대체하는 한 부분으로서 제공

<br>

### 접근 제어 모델이란?
<br>

> 프레임워크로 주체가 어떨게 객체에 접근하는 지 설명하는 모델

* 주체의 객체 사용데 대한 엄격한 정의를 내리게 된다.

- 주체가 객체에 접근하려는 접근 시도가 생성되면 이를 허용할 것인지를 결쩡하기 위해 접근통제 모델을 이용


<br>

#### 강제적 접근 통제 (MAC)

- Mandatory Access Control

- 보안 레이블과 보안 허가증을 비교하여 접근 제어

> 보안 레이블 : 특정 시스템 자원이 얼마나 중요한 자원인지를 나타내는 정보

> 보안 허가증 : 어떤 시스템 객체가 특정 자원에 접근할 수 있는지를 나타내는 정보

- 비밀서를 갖는 객체에 대하여 주체가 갖는 권한에 근거하여 객체에 대한 접근을 제어하는 방법

- 사용자의 의도와는 관계없이 의무적으로 접근을 제어하는 규칙 기반 접근 통제
- 장점
	* 보안성 우수

	* 중앙 집중식 관리 형태라 모든 객체에 대한 관리가 용이

- 단점
	* 모든 접근에 대해 레이블링의 정의하고 보안 정책을 확인해야 하므로 성능 저하 방생
	* 주로 군 시스템에 사용되며 상업적인 분야에서는 적용하기 어렵다

<br>

#### 임의적 접근 통제 (DAC)

- Discretionary Access Control

- 접근을 요청하는 자의 신원, 그리고 어떤 사람이 접근 승인이 되는 지를 나타내는 접근 규칙에 기반을 두는 접근 제어

- 한 개체가 자신의 의지로 다른 개체가 어떤 자원에 접근이 가능하도록 승인해주는 접근 권한을 가질수 있다

- 주체가 속해있는 그룹의 신원에 근거하여 객체에 대한 접근을 제한하는 방법으로 객체의 소유자가 접근 여부를 결정

- 분산형 보안관리 형태
	* 신원 기반 접근 통제
	* 사용자 기반 통제
	* 혼합 방식 접근 통제

- 임의적 접근 통제 : 일반적으로 ACL을 통해서 구현

- 통제의 기준이 주체의 신분에 근거를 두고 있으며 접근 통제 매커니즘이 데이터의 의미에 대해 아무 지식을 가지고 있지 않다

- 단점
	* 신분이 중요한 정보이기 때문에 다른 사람의 신분을 이용해서 불법적으로 접근할 수 있다
	* 중앙집중형 관리 방식인 강제적 접근 통제 모델보다 관이가 용이하지 않다

## apt & aptitude

###  Apt 란?

> Apt => Advanced Package Tool 시스템에 포함된 핵심 도구들의 집합

- Apt로 처리 할 수 있는 작업
  - 응용프로그램 설치
  - 응용프로그램 삭제
  - 응용프로그램을 항상 최신버전으로 유지
  - 등등....

### dpkg 란?

> dpkg => 데비안 패키지 관리 시스템의 기초가 되는 소프트웨어

- deb패키지(확장자가 .deb로 끝나는 파일)의 설치, 삭제를 위해 사용

### aptitude

- dpkg와 apt의 경우 제대로 사용하기 위해서는 좀 더 많은 지식을 요구한다. 그에 비하여 aptitude의 경우 주요 패키지 작업 과정을 자동화하여 가능한 쉽게 작업할 수 있도록 해주므로 보다 쉽게 할 수 있다.

- aptitude는 사용하지 않는 패키지를 자동적으로 제거해준다. 반면, apt는 추가적 옵션 필요
  
- aptitude는 why와 why-not커맨드를 통해 특정 패키지를 설치할 때 어떤 것이 요구되고, 어떤 것과 충돌하는지 확인할 수 있다.
  
- aaptitude는 설치, 제거, 업데이트 과정에서 충돌이 있는 경우 다른 대안을 제시해 준다.(apt는 그냥 안된다고 함)

## UFW 란?

> 미리 정의된 보안 규칙에 기반한, 들어오고 나가는 네트워크 트래픽을 모니터링하고 제어하는 네트워크 보안 시스템

- 일반적으로 신뢰할 수 있는 내부 네트워크, 신뢰할 수 없는 외부 네트워크간의 장벽을 구성
- 서로 다른 네트워크를 지나는 데이터를 허용하거나 거부하거나 검열, 수정하는 하드웨어나 소프트웨어 장치 

- 역할 
  - 신뢰 수준이 다른 네트워크 구간들 사이에 놓여서 신뢰 수준이 낮은 네트워크로부터 오는 해로운 트래픽이 신뢰 수준이 높은 네트워크로 오지 못하게 막는 것

## SSH

> SSH (Secure Shell) 보안을 중요시한 프로토콜


- 원격 터미널 접속은 왜 필요할까?

  - 다양한 원격 접속 프로그램을 사용 원격지에 있는 서버에 굳이 찾아가지 않고 해당 서버의 주소만 알고 있다면 다른 pc를 통하여 바로 접속
  

- 안전하지 않은 기존의 TCP 연결을 안전한 SSH로 변환하는 과정

- 용도
  - 사용자 및 자동화된 프로세스에 대한 보안 엑세스 제공
  
  - 파일 전송 기능
  - 원격 명령 실행
  - 네트워크 인프라 및 기타 시스템 구성 요소 관리

- 특징
  - 클라이언트에서 호스트로 입력을 전송하고 출력을 다시 클라이언트로 릴레이하는 매커니즘 제공
  
  - HTTPS의 경우 웹 브라우저가 서버와 통신하여 웹사이트를 표시하지만 SSH는 쉘이 브라우저와 서버 뿐만 아니라 두 장치 간의 데이터 교환 또는 통신이 가능
  - 운영체제와 통신 가능
  - 암호화 기술을 사용하여 원격 서버와의 모든 통신을 암호화

- 패킷이란?
  - 정보 기술에서 패킷 방식의 컴퓨터 네트워크가 전달하는 데이터의 형식화된 블록
  
    - 즉, 콤퓨터 네트워크에서 데이터를 주고받을 때 정해 놓은 규칙

  - 정보를 보낼 때 특정 형태를 맞추어 보낸 다는 것
  
    - 컴퓨터 간에 데이터를 주고받을 때 네트워크를 통해서 전송되는 데이터 조각이라고 생각하면 편함

- 연결 흐름
    1. 클라이언트가 서버에 연결을 시도
   
    2. 서버 측에서 public key를 클라이언트에 전송
   
    3. 서버와 클라이언트 간 사용할 수 있는 보안 파라미터를 협상하고 보안 채널을 생성

    4. 서버 호스트 운영체제에 로그인

<br>

- 왜 굳이 Talnet도 있는 데 SSH를 사용 할까?
  - Talnet은 보안적으로 치명적인 결함이 있음
  
    - SSH 프로토콜을 사용시에는 암호화된 통신을 하여 식별할 수 없는 내용으로 패킷이 보내짐
  
    - Talnet에 경우 일반 문자열이 출력 되었을 때 별도의 암호화가 되지 않음

- SSH Server 설치 조건
  - 22번 tcp 포트가 방화벽에서 열려있어야 한다
  
  - SSH 서버 프로그램이 설치 및 구동이 되어야 한다.
  
  - SSH 프로토콜로 접속할 수 있는 SSH 클라이언트가 필요
  
- SSH 규칙 설정 및 서버의 연결 설정 정의
	- /etc/sshd/sshd_config 설정 파일을 참조
  
	- 내용 편집 기능
  
    	- SSH 포트 변경
  
    	- 접속 허용 클라이언트 및 패스워드 입력 시도 횟수 제한 설정
  
    	- 패스워드, 공개 키 사용자 인증 설정
  
    	- 접속 로그, 배너 메세지

## SUDO

- 유닉스 및 유닉스 계열 운영체제에서, 다른 사용자의 보안 권한, 보통 슈퍼유저로서 프로그램을 구동할 수 있도록 하는 프로그램
  
  - 관리자의 권한을 빌릴때 사용
  
> "Substitute user do" (다른 사용자의 권한으로 실행)의 줄임말

### sudoer 파일

  - sudo 명령어를 사용할 수 있는 계정을 관리하는 설정 파일
  - /etc 폴더에 존재


### 마지막 줄 sudoer 파일 추가 
~~~shell
Defaults    authfail_message="Authentication attempt failed."
Defaults    badpass_message="Wrong password!"
Defaults    log_input
Defaults    log_output
Defaults    requiretty
Defaults    iolog_dir="/var/log/sudo/"
~~~

- authfail_message="메세지" : 권한 획득 실패시 띄울 커스텀 메시지
- badpass_message="메시지" : 암호 실패시 띄울 메시지
- log_input : sudo를 통해 입력된 input은 로그에 기록된다.
- log_output : sudo를 통해 입력된 output은 로그에 기록된다.
- requiretty : tty에 연결되지 않은 채로 sudo를 실행하는 것을 금지? ex. 쉘 스크립트 상에서 sudo 커맨드 수행 금지.
- iolog_dir="경로" : 로그를 저장할 경로.
  